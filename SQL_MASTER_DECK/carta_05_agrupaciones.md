# CARTA 05: GROUP BY Y FUNCIONES DE AGREGACI√ìN üéØ

**Objetivo**: Dominar el arte de resumir y analizar datos mediante agrupaciones

## üéØ LO ESENCIAL QUE DEBES SABER
`GROUP BY` transforma **datos detallados** en **informaci√≥n resumida**.  
Es la herramienta para calcular totales, promedios, contar ocurrencias y convertir millones de filas en KPIs √∫tiles para reportes y dashboards.

- `GROUP BY` **colapsa filas** por una(s) columna(s) (la dimensi√≥n) y aplica funciones de agregaci√≥n (las m√©tricas).
- Usa `WHERE` para filtrar filas **antes** de agrupar; usa `HAVING` para filtrar **grupos** ya formados.
- Piensa: **dimensi√≥n** = c√≥mo agrupas (empresa, pa√≠s, mes). **M√©trica** = qu√© mides (SUM, AVG, COUNT).

---

üìä TABLAS DE EJEMPLO (CONTINUAMOS CON TUS DATOS)
```sql
-- üè¢ TABLA: company
id | company_name   | country    | employees
1  | TechCorp       | USA        | 150
2  | DataSystems    | Germany    | 80
3  | StartUpWX      | France     | 10

-- üí∞ TABLA: transactions
id | company_id | amount | status    | timestamp
1  | 1          | 1208   | approved  | 2024-01-15
2  | 2          | 800    | approved  | 2024-01-16
3  | 1          | 2500   | pending   | 2024-01-17
4  | 1          | 1800   | approved  | 2024-01-18
```
üíª LAS 5 FUNCIONES DE AGREGACI√ìN QUE DOMINAR√ÅS
1. COUNT() - CONTAR REGISTROS
```sql
-- üìù Cu√°ntas transacciones tiene cada empresa
-- üí° √ötil para: saber actividad por empresa, identificar empresas inactivas
SELECT c.company_name, COUNT(t.id) as total_transacciones
FROM company c 
LEFT JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name;
```
üìã RESULTADO:
```sql
company_name |	total_transacciones
TechCorp     |  3
DataSystems	 |  1
StartUpWX	 |  0
```
Uso: actividad, volumen, detectar inactividad (COUNT = 0).

2. SUM() - TOTALIZAR VALORES
```sql
-- üìù Total de ventas por empresa
-- üí° √ötil para: reportes de ingresos, an√°lisis de performance
SELECT c.company_name, SUM(t.amount) as ventas_totales
FROM company c 
LEFT JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name;
```
üìã RESULTADO:
```sql
company_name | ventas_totales
TechCorp	 | 5508
DataSystems	 | 800
StartUpWX	 | NULL
```
Nota: SUM sobre NULL devuelve NULL si no hay filas; usa COALESCE(SUM(...), 0) para 0.

3. AVG() - CALCULAR PROMEDIOS
```sql
-- üìù Promedio de transacciones por empresa
-- üí° √ötil para: entender el ticket promedio, identificar patrones de compra
SELECT c.company_name, AVG(t.amount) as promedio_ventas
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name;
```
üìã RESULTADO:
```sql
company_name | promedio_ventas
TechCorp	 | 1836.00
DataSystems	 | 800.00
```
Cuidado: AVG ignora NULL. Aseg√∫rate de la granularidad adecuada (por ejemplo, filtrar por status si es necesario).

4. MAX() / MIN() - ENCONTRAR EXTREMOS
```sql
-- üìù Transacci√≥n m√°s grande y m√°s peque√±a por empresa
-- üí° √ötil para: identificar outliers, entender rango de operaciones
SELECT 
    c.company_name,
    MAX(t.amount) as transaccion_maxima,
    MIN(t.amount) as transaccion_minima
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name;
```
üìã RESULTADO:
```sql
company_name | transaccion_maxima | transaccion_minima
TechCorp	 | 2500	              | 1208
DataSystems	 | 800	              | 800
```
Uso: detectar outliers, l√≠mites operativos.

5. COMBINACI√ìN MULTIPLE - EL REPORTE DEFINITIVO
```sql
-- üìù Resumen ejecutivo completo por empresa
-- üí° √ötil para: dashboards, reportes de management, an√°lisis estrat√©gico
SELECT 
    c.company_name,
    c.country,
    COUNT(t.id) as total_transacciones,
    SUM(t.amount) as ventas_totales,
    AVG(t.amount) as promedio_ventas,
    MAX(t.amount) as venta_maxima,
    MIN(t.amount) as venta_minima
FROM company c 
LEFT JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name, c.country;
```
Pr√°ctico para dashboards y reportes de management.

## üöÄ WHERE vs HAVING ‚Äî La diferencia que cambia todo

- WHERE filtra filas antes del GROUP BY.
- HAVING filtra grupos despu√©s de agrupar (usa agregados en la condici√≥n).

```sql
-- üìù Promedio de transacciones APROBADAS por empresa
-- üí° WHERE se ejecuta ANTES del GROUP BY - filtra transacciones individuales
SELECT c.company_name, AVG(t.amount) as promedio_aprobado
FROM company c 
JOIN transactions t ON c.id = t.company_id
WHERE t.status = 'approved'  -- Solo transacciones aprobadas
GROUP BY c.company_name;
```
HAVING - FILTRAR DESPU√âS DE AGRUPAR (FILTRA GRUPOS COMPLETOS)
```sql
-- üìù Empresas con promedio de ventas mayor a 1000
-- üí° HAVING se ejecuta DESPU√âS del GROUP BY - filtra empresas completas
SELECT c.company_name, AVG(t.amount) as promedio_ventas
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name
HAVING AVG(t.amount) > 1000;  -- Solo empresas que cumplan condici√≥n
```
**Patr√≥n √∫til: WHERE para aplicar reglas de negocio a filas; HAVING para reglas a la m√©trica resultante.**

WHERE + HAVING - COMBINACI√ìN PODEROSA
```sql
-- üìù Empresas con promedio de transacciones APROBADAS mayor a 1500
-- üí° WHERE filtra transacciones, HAVING filtra empresas resultantes
SELECT c.company_name, AVG(t.amount) as promedio_aprobado
FROM company c 
JOIN transactions t ON c.id = t.company_id
WHERE t.status = 'approved'     -- Primero: solo transacciones aprobadas
GROUP BY c.company_name
HAVING AVG(t.amount) > 1500;   -- Luego: solo empresas con promedio alto
```
üîç PATRONES AVANZADOS DE TUS SPRINTS
AN√ÅLISIS POR PA√çS (SPRINT 2 - EJERCICIO 2.2)
```sql
-- üìù Media de ventas por pa√≠s - usado en tu Sprint 2
-- üí° Patr√≥n: Agrupar por dimensi√≥n geogr√°fica para an√°lisis regional
SELECT c.country, AVG(t.amount) as avg_amount
FROM company c 
JOIN transaction t ON t.company_id = c.id
GROUP BY c.country
ORDER BY avg_amount DESC;
```
IDENTIFICAR EMPRESAS DESTACADAS (SPRINT 2 - EJERCICIO 3.1)
```sql
-- üìù Empresas con transacciones sobre el promedio - usado en tu Sprint 2
-- üí° Patr√≥n: Subconsulta en HAVING para comparar con m√©tricas globales
SELECT c.company_name, AVG(t.amount) as promedio_empresa
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name
HAVING AVG(t.amount) > (SELECT AVG(amount) FROM transactions);
```
AN√ÅLISIS TEMPORAL (PATR√ìN PARA FUTUROS SPRINTS)
```sql
-- üìù Ventas totales por mes - preparaci√≥n para an√°lisis temporal
-- üí° Patr√≥n: GROUP BY con funciones de fecha para an√°lisis temporal
SELECT 
    YEAR(timestamp) as a√±o,
    MONTH(timestamp) as mes,
    SUM(amount) as ventas_totales
FROM transactions
GROUP BY YEAR(timestamp), MONTH(timestamp)
ORDER BY a√±o, mes;
```
üéØ PREGUNTAS T√çPICAS DE "PROFE" (EXTRA√çDAS DE TUS SPRINTS)
PREGUNTA 1:
"¬øCu√°l es la empresa con el mayor promedio de ventas por transacci√≥n?"
```sql
-- Tu respuesta deber√≠a ser:
SELECT c.company_name, AVG(t.amount) as promedio_ventas
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name
ORDER BY promedio_ventas DESC
LIMIT 1;
```
PREGUNTA 2:
"¬øQu√© pa√≠ses tienen m√°s de 3 transacciones en total?"

```sql
-- Tu respuesta deber√≠a ser:
SELECT c.country, COUNT(t.id) as total_transacciones
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.country
HAVING COUNT(t.id) > 3;
```
PREGUNTA 3:
"Muestra el total de ventas por empresa, pero solo para empresas con m√°s de 2000 en ventas totales"

```sql
-- Tu respuesta deber√≠a ser:
SELECT c.company_name, SUM(t.amount) as ventas_totales
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name
HAVING SUM(t.amount) > 2000;
```
üß∞ EXTRAS QUE TE HACEN BRILLAR (pr√°ctico + avanzado)
Manejo elegante de NULL:
``` sql
SELECT 
  c.company_name,
  COALESCE(SUM(t.amount), 0) AS ventas_totales,
  COALESCE(AVG(t.amount), 0) AS promedio_ventas
FROM company c 
LEFT JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name;
```
COALESCE evita NULL y deja 0 cuando no hay datos.

Ordena siempre tus resultados para lectura profesional:
``` sql
SELECT c.company_name, SUM(t.amount) AS ventas_totales
FROM company c 
JOIN transactions t ON c.id = t.company_id
GROUP BY c.company_name
ORDER BY ventas_totales DESC;
``` 
## üêû ERRORES FRECUENTES (ev√≠talos as√≠)

- Poner en SELECT columnas no agrupadas ni agregadas ‚Üí error o resultado indeterminado.
- Usar WHERE para filtrar grupos ‚Üí convertir√°s LEFT JOIN en INNER sin querer.
- Olvidar COALESCE ‚Üí ver√°s NULL donde esperas 0.
- No ordenar los resultados ‚Üí malas decisiones por datos sin jerarqu√≠a visual.

üí° EL CONSEJO MILLONARIO
"WHERE filtra filas individuales ANTES de agrupar, HAVING filtra grupos completos DESPU√âS de agrupar - esta diferencia es la clave para reportes precisos"

TU PLANTILLA MENTAL PARA CUALQUIER GROUP BY:

PASO 1: IDENTIFICA LA DIMENSI√ìN DE AN√ÅLISIS
```SQL
¬øPor empresa? ‚Üí GROUP BY company_name
¬øPor pa√≠s? ‚Üí GROUP BY country
¬øPor fecha? ‚Üí GROUP BY DATE(timestamp)
¬øPor estado? ‚Üí GROUP BY status
```
PASO 2: SELECCIONA LAS M√âTRICAS CLAVE
```SQL
¬øVolumen? ‚Üí COUNT()
¬øIngresos? ‚Üí SUM()
¬øEficiencia? ‚Üí AVG()
¬øRango? ‚Üí MAX()/MIN()
```
PASO 3: APLICA FILTROS ESTRAT√âGICOS
```SQL
¬øFiltrar datos crudos? ‚Üí WHERE (ej: solo transacciones aprobadas)
¬øFiltrar resultados? ‚Üí HAVING (ej: solo empresas con ventas > X)
```
PASO 4: CONSTRUYE POR CAPAS - EJEMPLO REAL

```sql
-- Capa 1: Datos base
SELECT company_name, amount, status
FROM company JOIN transactions...

-- Capa 2: Agregaci√≥n b√°sica  
SELECT company_name, COUNT(*), AVG(amount)
FROM ... GROUP BY company_name

-- Capa 3: Filtros estrat√©gicos
SELECT company_name, COUNT(*), AVG(amount)
FROM company JOIN transactions 
WHERE status = 'approved'        -- filtro individual
GROUP BY company_name
HAVING AVG(amount) > 1000        -- filtro grupal
```
üéØ TU NUEVO SUPERPODER
Ahora puedes transformar millones de filas en insights accionables:

‚úÖ Reportes ejecutivos en segundos
‚úÖ Identificar patrones y tendencias ocultas
‚úÖ Detectar empresas destacadas y problem√°ticas
‚úÖ Preparar datos para dashboards y presentaciones
‚úÖ Responder preguntas complejas de negocio

Cada GROUP BY que escribas revelar√° informaci√≥n estrat√©gica escondida en tus datos.

[‚Üê Carta 04: JOINS entre Tablas](carta_04_joins.md) | [üìö Ir al √çndice](INDICE_PRINCIPAL.md) | [Carta 06: Subconsultas ‚Üí](carta_06_subconsultas.md)



